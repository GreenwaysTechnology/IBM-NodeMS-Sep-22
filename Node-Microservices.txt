				Microservices
.....................................................................................

What is Micro service?
   Microservices - also known as the microservice architecture - is an architectural style that structures an application as a collection of services that are

Highly maintainable and testable
1.Loosely coupled
2.Independently deployable
3.Organized around business capabilities
4.Owned by a small team

The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.

Microservices are based on Design patterns:

1.Service Design pattern
2.Data Management Pattern
3.Deployment Pattern
4.Cross Cutting Patterns
5.Communication style patterns
6.Service Design pattern
7.Reliablity Pattern
8.Security Pattern
9.Observablity Pattern
.....................................................................................				Micro service Implemenation
...................................................................................

Micro services can be implemeneted in any language 

Java :

1.Spring Cloud
2.Vertx
3.Quarkus

Javascript (Node.js):
1.Moleculer
2.Loopback


What is Moleculer?
  Moleculer is open source Micro service framework.

Features of Moleculer:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
plugin/middleware system
7.support versioned services
8.support Streams
9.service mixins
10.built-in caching solution (Memory, MemoryLRU, Redis)
11.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
12.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
13.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
14.pluggable parameter validator
15.multiple services on a node/server
16.master-less architecture, all nodes are equal
17.parameter validation with fastest-validator
18.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
19.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
20.official API gateway, Database access and many other modules…

....................................................................................
				Project Setup
....................................................................................

1.normal node project 
2.using moleculer cli

Project creation:
.................

E:\session\IBM\2022\sep\nodejsmicroservice>mkdir microserviceapp

E:\session\IBM\2022\sep\nodejsmicroservice>cd microserviceapp

E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp>npm init --yes
Wrote to E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\package.json:

{
  "name": "microserviceapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}

E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp>mkdir services

npm install moleculer --save


Core concepts in Molecular:
..........................

1.Service:

 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.
 A Service is Object which represents  domain.

2.Service Broker : == Spring Container
  Service Broker is the heart of Moleculer.

ServiceBroker is Object === Express Application Object

Role of ServiceBroker:

 Provides all ms infra tools - service registery,load balancer,communication infra.
 ....
3.Node:
  A node is a simmple os process running o local or external network. A single node Instance
 can have single Broker, each broker can have multiple services

4.Transorter:
   Transporter is communication bus that services use to exchange messages.
   It transfers request,response,events...

5.Api GateWay:
    Component which exposes/facilates to communicate outside world 
.....................................................................................
			  Service Representation


1.REST Service
2.Back end Service -RPC
3.GraphQL

later we will see "REST Service"

RPC based Service Representation:

services/helloworld.service.js

const { ServiceBroker } = require('moleculer')

//create instance of service Broker 
const broker = new ServiceBroker()



>node services/helloworld.service.js
[2022-09-28T10:01:03.447Z] INFO  laptop-r2tggfdl-2080/BROKER: Moleculer v0.14.23 is starting...
[2022-09-28T10:01:03.449Z] INFO  laptop-r2tggfdl-2080/BROKER: Namespace: <not defined>
[2022-09-28T10:01:03.449Z] INFO  laptop-r2tggfdl-2080/BROKER: Node ID: laptop-r2tggfdl-2080
[2022-09-28T10:01:03.451Z] INFO  laptop-r2tggfdl-2080/REGISTRY: Strategy: RoundRobinStrategy
[2022-09-28T10:01:03.452Z] INFO  laptop-r2tggfdl-2080/REGISTRY: Discoverer: LocalDiscoverer
[2022-09-28T10:01:03.458Z] INFO  laptop-r2tggfdl-2080/BROKER: Serializer: JSONSerializer
[2022-09-28T10:01:03.468Z] INFO  laptop-r2tggfdl-2080/BROKER: Validator: FastestValidator
[2022-09-28T10:01:03.470Z] INFO  laptop-r2tggfdl-2080/BROKER: Registered 13 middleware(s).
[2022-09-28T10:01:03.584Z] INFO  laptop-r2tggfdl-2080/$NODE: Service '$node' stopped.
[2022-09-28T10:01:03.585Z] INFO  laptop-r2tggfdl-2080/BROKER: ServiceBroker is stopped. Good bye.

..................................................................................
				How to create a Service
....................................................................................

Service is Object , created using broker.createService(serviceDefintionObject)

service Defintion Object has lot of properties:
name  - each service must have name
actions - object which has methods of service


const { ServiceBroker } = require('moleculer')

//create instance of service Broker 
const broker = new ServiceBroker()

//create service :
broker.createService({
    name: 'HelloWorld',
    actions: {
        //service api
        sayHello() {
            return 'Hello,Moleculer'
        }
    }
})

//start moleculer server()
function main(){
    broker.start()
}
main()



How to invoke/call Service methods?

There are many ways

1.By using broker.start method
2.By using  REPL cli
3.By using another service => Service to Service calls

const { ServiceBroker } = require('moleculer')

//create instance of service Broker 
const broker = new ServiceBroker()

//create service :
broker.createService({
    name: 'HelloWorld',
    actions: {
        //service api
        sayHello() {
            return 'Hello,Moleculer'
        }
    }
})

//start moleculer server(brower)
function main() {
    broker.start()
        .then(() => {
            console.log("Moleculer server is succfully started")
            //invoke service
            broker.call('HelloWorld.sayHello')
                .then(res => console.log(res))
                .catch(err => { console.log(err) })
        })
        .catch(err => {
            console.log("Moleculer server faile  to server")
        })
}
main()
...................................................................................
			How to refactor code
....................................................................................
async function main() {
    try {
        await broker.start()
        const res = await broker.call('HelloWorld.sayHello')
        console.log(res)

    } catch (err) {
        console.log(err)
    }
}
main()
.......................................&&&&&&&&&&&&.................................
				Service Multiple Methods
.....................................................................................
const { ServiceBroker } = require('moleculer')

//create instance of service Broker 
const broker = new ServiceBroker()

//create service :
broker.createService({
    name: 'HelloWorld',
    actions: {
        //service api
        sayHello() {
            return 'Hello,Moleculer'
        },
        sayHai() {
            return 'Hai,Moleculer'
        },
        sayGreet() {
            return 'Greet,Moleculer'
        }
    }
})
async function main() {
    try {
        await broker.start()
        const hello = await broker.call('HelloWorld.sayHello')
        const hai = await broker.call('HelloWorld.sayHai')
        const greet = await broker.call('HelloWorld.sayGreet')

        console.log(hello,hai,greet)

    } catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			Multiple Service
.....................................................................................
const { ServiceBroker } = require('moleculer')

//create instance of service Broker 
const broker = new ServiceBroker()

broker.createService({
    name: 'hello',
    actions: {
        //service api
        sayHello() {
            return 'Hello,Moleculer'
        }
    }
})
broker.createService({
    name: 'hai',
    actions: {
        //service api
        sayHai() {
            return 'Hai,Moleculer'
        }
    }
})
broker.createService({
    name: 'greet',
    actions: {
        //service api
        sayGreet() {
            return 'Greet,Moleculer'
        }
    }
})
async function main() {
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello')
        const hai = await broker.call('hai.sayHai')
        const greet = await broker.call('greet.sayGreet')

        console.log(hello, hai, greet)

    } catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			    Service api parameters
....................................................................................

How to pass params to Service methods? How to read args from the service Method?

Parameters are stored inside special object called "Context"

Context Object:

1.Similar to Broker Object
2.It has all capacity of Broker object
3.Context object is used inside service definitions , where ever you require broker
  Object reference.

context object already created, and its refernce is avaiable inside "Service method" as args.

reading parameters

1.context.params 
  params are literal object what ever parameter we pass, it will inside this

context.params.variable


Passing args to service method:
  Passing args to service method as Object. {}

broker.call('hello.sayHello',{})

....................................................................................
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

//create service :
broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            const name = ctx.params.name
            return `Hello ${name}`
        }
    }
})
//
broker.createService({
    name: 'math',
    actions: {
        multiply(ctx) {
            const a = ctx.params.a
            const b = ctx.params.b
            return a * b
        }
    }
})


async function main() {
    try {
        await broker.start()
        //params are passed as single literal object 
        const res1 = await broker.call('hello.sayHello', { name: 'Subramanian' })
        console.log(res1)
        const res2 = await broker.call('hello.sayHello', { name: 'Ford' })
        console.log(res2)

        const multply = await broker.call('math.multiply', { a: 10, b: '10' })
        console.log(multply)


    } catch (err) {
        console.log(err)
    }
}
main()
.............................*********..............................................
				 actions Syntax:

1.normal pattern

   actions: {
        multiply(ctx) {
            const a = ctx.params.a
            const b = ctx.params.b
            return a * b
        }
    }

2.expanded Pattern
    -This pattern is very usefull for having additional information for a methods.
     or meta information.

 params,cache,fallback---extra information information

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

//create service :
broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            const name = ctx.params.name
            return `Hello ${name}`
        }
    }
})
//
broker.createService({
    name: 'math',
    actions: {
        //normal pattern 
        multiply(ctx) {
            const a = ctx.params.a
            const b = ctx.params.b
            return a * b
        },
        divide: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a / b
            }
        }
    }
})


async function main() {
    try {
        await broker.start()
        //params are passed as single literal object 
        const res1 = await broker.call('hello.sayHello', { name: 'Subramanian' })
        console.log(res1)
        const res2 = await broker.call('hello.sayHello', { name: 'Ford' })
        console.log(res2)

        const multply = await broker.call('math.multiply', { a: 10, b: '10' })
        console.log(multply)


        //this code will throw validation error
        //const div = await broker.call('math.divide', { a: 10, b: '10' })
        const div = await broker.call('math.divide', { a: 10, b: 10 })
        console.log(div)


    } catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
		    Dynamic Parameters and dynamic invocation of services
...................................................................................

Moleculer has a tool called "Moleculer REPL"
>npm install moleculer-repl --save



const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        divide: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a / b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()
   
    } catch (err) {
        console.log(err)
    }
}
main()

mol $ call math.divide --a 10000 --b 234
>> Call 'math.divide' with params: { a: 10000, b: 234 } with meta: { '$repl': true } with options: {}
>> Execution time:4ms
>> Response:
42.73504273504273
.....................................................................................
			 Microservice communications -Communications Style
....................................................................................

Micro service communications happens across the applications or within applications.

Service Representation

1.rpc 
2.rest
3.graphql

Service communications

1.rpc to rpc

2.rest to rest

2.rest to rpc


Moleculer is microservice, generally microservices may be distributed across multiple machines(nodes) , which communicates via networks.


1.Service communication with in single broker

2.Service communication across multiple service brokers

Communication style

1. can be sync
2. can be async

RPI style
   method to method call
Event driven style
   methods communicates via events.


Types of services:

1.local service
   service which is implemented on single broker.
2.remote service
   Service which is implemented across the brokers.
 
Services can communicate within service broker-single node arch
Services can communicate across service brokers - multi node arch

How services are interacting each other?

 Using "Context" Object

Actors:

 1.Caller service, who is calling /consuming other services

 2.Callee service, who is called by others


Use case: Service to Service : RPI TO RPI - Method to method call - on single broker
...................................................................................

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //call adder.add 
                return ctx.call('adder.add', { a: a, b: b })
            }
        }
    }

})
broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                //object destructuring: - break object properties 
                const { a, b } = ctx.params
                return a + b
            }
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main()

mol $ call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 } with meta: { '$repl': true } with options: {}
>> Execution time:3ms
>> Response:
30
mol $

....................................................................................
				  Remote Service Communication
.....................................................................................

Microservices are loosly coupled services, runs indendently, how do they communicate

Remote Services
-Services are located across the nodes.
-nodes can be the same machine or different machines, or cloud.

Run two services in a different node.

node services/remote1.service.js

node services/remote2.service.js


remote1.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //call adder.add 
                return ctx.call('adder.add', { a: a, b: b })
            }
        }
    }

})
async function main() {
    await broker.start()
    broker.repl()
}
main()
.........................
remote2.service.js


const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                //object destructuring: - break object properties 
                const { a, b } = ctx.params
                return a + b
            }
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main()

mol $ call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 } with meta: { '$repl': true } with options: {}
[2022-09-29T04:52:49.424Z] WARN  laptop-r2tggfdl-22476/BROKER: Service 'adder.add' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'adder.add' is not found.
    at ServiceBroker.findNextActionEndpoint (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\service-broker.js:1130:13)
    at ServiceBroker.call (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\service-broker.js:1179:26)
    at Context.call (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\context.js:286:23)
    at Service.handler (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\services\remote1.service.js:13:28)
    at E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\utils.js:212:22
    at ServiceBroker.timeoutMiddleware (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\middlewares\timeout.js:31:14)
    at ServiceBroker.fallbackMiddleware (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\middlewares\fallback.js:31:11)
    at ServiceBroker.errorHandlerMiddleware (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
    at ServiceBroker.call (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer\src\service-broker.js:1203:31)
    at handler (E:\session\IBM\2022\sep\nodejsmicroservice\microserviceapp\node_modules\moleculer-repl\src\commands\call.js:131:28)
Data:  { action: 'adder.add' }

Why the above error?

-Service not able to locate the other service, since other services are running in different nodes


In order to enable Remote Service communications , we need Transporters

Transporter is a channel and bridge layer among services.


In order to enable Remote Service communications , we need Message Brokers 


Transporters:

-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporter
TCP transporter - part of moleculer

Third party Brokers

NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter

TCP transporter:

This is a no-dependency, zero-configuration TCP transporter.
It uses Gossip protocol to disseminate node statuses, service list and heartbeats.
It contains an integrated UDP discovery feature to detect new and disconnected nodes on the network.
If the UDP is prohibited on your network, use urls option. It is a list of remote endpoints (host/ip, port, nodeID). It can be a static list in your configuration or a file path which contains the list.
 

Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transport.

ServiceBroker object creation:

const broker = new ServiceBroker();

 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker({
    transporter:"TCP"
});

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //call adder.add 
                return ctx.call('adder.add', { a: a, b: b })
            }
        }
    }

})
async function main() {
    await broker.start()
    broker.repl()
}
main()

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                //object destructuring: - break object properties 
                const { a, b } = ctx.params
                return `${broker.nodeID} -> ${a} + ${b}`
            }
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main()
......................************..................................................
mol $ call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 } with meta: { '$repl': true } with options: {}
>> Execution time:6ms
>> Response:
'laptop-r2tggfdl-15124 -> 10 + 20'
.....................................................................................
			      Service communication via 
		   Third party brokers - NATS,Redis,RabbitMQ,Kaffka


NATS:
Steps:
1.You need to start NATS server.
https://nats.io/download/

docker run -p 4222:4222 -ti nats:latest


2.configure in service broker

const broker = new ServiceBroker({
    nodeID : 'IBM-Adder Service',
    transporter: "nats://localhost:4222"
});

3.install nats dirver package
npm install nats --save

4.Run nodes as usual
....................................................................................
				Serialization
Transporter needs a serializer module which serializes & deserializes the transferred packets. 
The default serializer is the JSONSerializer but there are several built-in serializer.

const { ServiceBroker } = require('moleculer')


const broker = new ServiceBroker({
  //  transporter:"TCP"
  transporter: "nats://localhost:4222",
  serializer: "JSON" // not necessary to set, because it is the default

});

..
const { ServiceBroker } = require('moleculer')

// const broker = new ServiceBroker({
//     transporter: "TCP"
// })
const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    serializer: "JSON"
})
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //call adder.add 
                return ctx.call('adder.add', { a: a, b: b })
            }
        }
    }

})
broker.createService({
    name:'customer',
    actions: {
        list: {
            handler(ctx){
                return ctx.call('product.list')
            }
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main()
...........
const { ServiceBroker } = require('moleculer')

// const broker = new ServiceBroker({
//     transporter: "TCP"
// })
const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    serializer: "JSON"
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                //object destructuring: - break object properties 
                const { a, b } = ctx.params
                return `${broker.nodeID} -> ${a} + ${b}`
            }
        }
    }
})

broker.createService({
    name: 'product',
    actions: {
        list: {
            handler(ctx) {
                return [{ id: 1, name: 'Phone', qty: 10, price: 100 }, { id: 2, name: 'TV', qty: 10, price: 340 }]
            }
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main()
....
mol $ call product.list
>> Call 'product.list' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:2ms
>> Response:
[
  { id: 1, name: 'Phone', qty: 10, price: 100 },
  { id: 2, name: 'TV', qty: 10, price: 340 }
]
..........................********...................................................
.....................................................................................
			Loosly Coupled Service Communication
				Event Driven Archs
			 How to communicate via events
....................................................................................

Broker has a built-in event bus to support Event-driven architecture and to send events to local and remote services.


Callee: Events Listeners

   events: {
        "order.created": {
            handler(ctx) {
                console.log("Payload:", ctx.params);
                console.log("Sender:", ctx.nodeID);
                console.log("Metadata:", ctx.meta);
                console.log("The called event name:", ctx.eventName);
            }
        }
    }
   

caller: Event emission

 broker/ctx.emit("order.created",{order:{id:1,name:'test'}}) - one to one
 broker/ctx.broadcast("order.created",{order:{id:1,name:'test'}}) - one to many


publisher.service.js
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker({
    transporter: "TCP"
});

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                // ctx.emit("adder.add", { a: ctx.params.a, b: ctx.params.b })
                ctx.broadcast("adder.add", { a: ctx.params.a, b: ctx.params.b })

                return 'Event has emitted'
            }
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        broker.repl();
    } catch (error) {
        console.log(error)
    }
}
main();

listener.service.js
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker({
    transporter: "TCP"
});

broker.createService({
    name: 'adder',
    events: {
        "adder.add": {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx){
                console.log("Payload:", ctx.params);
                console.log("Sender:", ctx.nodeID);
                console.log("Metadata:", ctx.meta);
                console.log("The called event name:", ctx.eventName);
            }
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        broker.repl();
    } catch (error) {
        console.log(error)
    }
}
main();

listener2.service.js
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker({
    transporter: "TCP"
});

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                // ctx.emit("adder.add", { a: ctx.params.a, b: ctx.params.b })
                ctx.broadcast("adder.add", { a: ctx.params.a, b: ctx.params.b })

                return 'Event has emitted'
            }
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        broker.repl();
    } catch (error) {
        console.log(error)
    }
}
main();
.....................................................................................
			      Service Configurations

				Methods Types

/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
    methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.

public methods:
 any thing if you write inside actions are called public methods.

actions { 


}

private methods:

createService({

 //public methods
 actions: {

 },

 //private methods
 methods: {


 }

})
const { ServiceBroker } = require('moleculer')

// const broker = new ServiceBroker({
//     transporter: "TCP"
// })
const broker = new ServiceBroker()
broker.createService({
    name: 'math',
    //public methods
    actions: {
        add: {
            handler(ctx) {
                const { a, b } = ctx.params
                //call private methods 
                return this.add(a, b)
            }
        }
    },
    //private methods  
    methods: {
        add(a, b) {
            return a + b
        }
    }

})


async function main() {
    await broker.start()
    broker.repl()
}
main()
....................................................................................
...................................................................................
			  Service Life Cycle methods
...................................................................................

Service life cycle methods are called by broker in various stages of services

Service life cycle methods are very usefull for doing some initalization, re initalizations tasks.


1. created() {
        // Fired when the service instance created (with `broker.loadService` or `broker.createService`)
    },

    merged() {
        // Fired after the service schemas merged and before the service instance created
    },
    
    async started() {
        // Fired when broker starts this service (in `broker.start()`)
    }

    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
    }

const { ServiceBroker } = require('moleculer')

// const broker = new ServiceBroker({
//     transporter: "TCP"
// })
const broker = new ServiceBroker()
broker.createService({
    name: 'math',
    //public methods
    actions: {
        add: {
            handler(ctx) {
                const { a, b } = ctx.params
                //call private methods 
                return this.add(a, b)
            }
        }
    },
    //private methods  
    methods: {
        add(a, b) {
            return a + b
        }
    },
    //life cycle methods
    created() {
        // Fired when the service instance created (with `broker.loadService` or `broker.createService`)
        console.log('service created')
    },

    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('service merged')
    },
    
    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('service stoped')
    }



})


async function main() {
    await broker.start()
    broker.repl()
}
main()
....................................................................................
				Service Dependencies
....................................................................................
Dependencies
  If your service depends on other services, use the dependencies property in the schema. 
The service waits for dependent services before calls the started lifecycle event handler.

Syntax:

dependencies: [
      "likes", // shorthand w/o version
      "v2.auth", // shorthand w version
      { name: "users", version: 2 }, // with numeric version
      { name: "comments", version: "staging" } // with string version
],
async started() {
      console.log("It will be called after all dependent services are available.");
      const users = await this.broker.call("users.list");
}

const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker();

broker.createService({
    name: 'comments',
    actions: {
        findAll() {
            return 'Comments'
        }
    },
    //Dependency
    dependencies: [
        "posts"
    ],
    //Life cycle methods
    created() {
        console.log('Comments Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Comments Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Comments Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Comments Service stoped')
    },

})


broker.createService({
    name: 'posts',
    actions: {
        findAll() {
            return [{ id: 1, name: 'Microservices' }]
        }
    },
    //Life cycle methods
    created() {
        console.log('Posts Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Posts Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Posts Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Posts Service stoped')
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl()
    } catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
....................................................................................
			 Service Code Reuse- Service Inheritance
....................................................................................

A Service has many options, those options may be repeated in many other services,
like common settings.

We can isloate common features / options into a separate service, we can reuse across multiple services -  Inheritance.

How to implement inheritance in moleculer?

Javascript can support only single inheritance, only one parent allowed for a child.

Java like languages support interfaces for multi parent patterns, javascript has no such facility.

Javascript has a design pattern and implementation ,called "mixin", through mixin we can inherit many super objects.

Moleculer has mixin property


Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.
etc...

Eg: in case of inheritance.....

Parent services are created using "plain javascript" not like broker.createService
...................**********************..........................................

inheritance.service.js
const { ServiceBroker } = require('moleculer')
const hello = require('./helloparent.service')
const broker = new ServiceBroker()

//parent services

const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai'
        }
    }
}



//child service 
broker.createService({
    name: 'greeter',
    mixins: [hello, hai],
    actions: {
        sayGreet() {
            return 'greet'
        }
    }
})


async function main() {
    await broker.start()
    broker.repl()
}
main()

helloparent.service.js
module.exports = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello'
        }
    }
}
.....................................................................................
		Defining Service Properties and How to override them

Service has 

1.methods called actions
2.properties which are defined inside "settings"
3.parent settings and actions can be overriden inside child service.
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//simulating some webserver settings

const webServer = {
    name: 'webserver',
    //parent properties
    settings: {
        port: 8080,
        host: 'ibm.com'
    }
}

broker.createService({
    name: 'MyWebServer',
    mixins: [webServer],
    //override existing properties
    settings: {
        port: 3000
    },
    actions: {
        getInfo() {
            return this.settings.port
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main() 
....................................................................................
...................................................................................
				Types of Services

Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object - broker.createService
2.Built services
  The services are provided by Broker
 $node
   Used for administration


Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object
2.Built services
  The services are provided by Broker
 $node
   Used for administration

How to list all services using $node
 call $node.services
>> Call '$node.services' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  },
  {
    name: 'greeter',
    version: undefined,
    fullName: 'greeter',
    settings: { port: 3000, host: 'ibm.com' },
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  }
]

$ call $node.list
>> Call '$node.list' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    id: 'laptop-r2tggfdl-17828',
    instanceID: 'c7fd8078-2bf2-42ee-88f6-1fd20184eb3c',
    available: true,
    local: true,
    lastHeartbeatTime: 0,
    config: {},
    client: { type: 'nodejs', version: '0.14.21', langVersion: 'v16.15.0' },
    metadata: {},
    ipList: [ '172.26.240.1', '172.22.176.1', '192.168.0.105' ],
    port: null,
    hostname: 'LAPTOP-R2TGGFDL',
    udpAddress: null,
    cpu: null,
    cpuSeq: null,
    seq: 3,
    offlineSince: null
  }
]

broker.createService({})
.....................................................................................
  			 Async service and Sync Service

Service returns data async - called async service
Service returns data sync -  called sync service...

const { ServiceBroker } = require('moleculer')


const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            async handler(ctx) {
                const result = await ctx.call('adder.add', { a: 10, b: 10 })
                return result
            }
        }
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                //return Promise 
                return new this.Promise((resolve, reject) => {
                    setTimeout(resolve, 5000, ctx.params.a + ctx.params.b)
                })
            }
        }
    }
})

async function main(){
    await broker.start()
    broker.repl()
}
main()
...................................................................................
			How to return stream as Response from the file
...................................................................................
const { ServiceBroker } = require('moleculer')
const fs = require('fs')
const path = require('path')

const broker = new ServiceBroker()

//stream service
broker.createService({
    name: 'storage',
    actions: {
        get: {
            handler(ctx) {
                const filePath = path.join(__dirname, 'assets/info.txt');
                const options = {
                    encoding: 'UTF-8'
                }
                const stream = fs.createReadStream(filePath, options)
                let data = ''
                stream.on('data', chunk => {
                    data += chunk
                })
                stream.on('end', () => {
                    console.log(chunk)
                })
            }
        }
    }
})


async function main() {
    await broker.start()
    broker.repl()
}
main()
....................................................................................
				RestFull WebService


Moleculer Modules:
..................

Moleculer core lib provides only how to create backend services, service interactions.

If i want to integrate lets say, rest api,databases, then we have to look at moleculer modules.

1.Gateways
2.Database and stores
3.Metrics & Tracing 
4.General 
5.Security
6.Tasks&Queues
7.Jobs
etc...
1.GateWay : moleculer-web:Official API Gateway for Moleculer framework.

Features:

support HTTP & HTTPS
serve static files
multiple routes
support global, route, alias middlewares
support file uploading
alias names (with named parameters & REST shorthand)
whitelist
multiple body parsers (json, urlencoded)
CORS headers
ETags
HTTP2
Rate limiter
before & after call hooks
Buffer & Stream handling
middleware mode (use as a middleware in ExpressJS Application)
support authorization and auth
.....................................................................................
			How to write first rest service
.....................................................................................

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

//create apigateWay
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})


async function main() {
    await broker.start()
}
main()

.................................................................................
				Greeter Rest Service

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

//create apigateWay
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello,Moleculer'
        }
    }
})

broker.createService({
    name: 'math',
    actions: {
        add() {
            return 10 + 10
        }
    }
})

async function main() {
    await broker.start()
}
main()



how to call backend service(rpc service) from the GateWay Service?

http://localhost:3000/servicename/methodname
http://localhost:3000/greeter/sayHello
http://localhost:3000/hello/sayHello
....................................................................................
			Distributed Rest Service



User----send Request------ApiGateWay --------Services

Front End Service:
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: "TCP",
    serializer: "JSON"
})

//create apigateWay
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                //call adder.add 
                return ctx.call('adder.add', { a: 10, b: 10 })
            }
        }
    }

})

async function main() {
    await broker.start()
}
main()
..................................
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP",
    serializer: "JSON"
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                //object destructuring: - break object properties 
                const { a, b } = ctx.params
                const result = a +b 
                return `${broker.nodeID} -> ${result}`
            }
        }
    }
})

async function main() {
    await broker.start()
    broker.repl()
}
main()
.....................................................................................
			 Configuration-Routers Configuration
.....................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: "TCP",
    serializer: "JSON"
})

// http://localhost:3000/api/math/add

//create apigateWay
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    settings: {
        routes: [{
            path: '/admin'
        },
        {
            path: '/api'
        }]
    }

})
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                return 10 + 10
            }
        }
    }

})

async function main() {
    await broker.start()
}
main()
.............................................................................................
    		How to restrict service method/actions access outside
				whiteList - configuration
.....................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: "TCP",
    serializer: "JSON"
})

// http://localhost:3000/api/math/add

//create apigateWay
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    settings: {
        routes: [{
            path: '/admin'
        },
        {
            path: '/api',
            whitelist: [
                "math.add",
                //"math*"
            ]

        }]
    }

})
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                return 10 + 10
            }
        },
        div: {
            handler(ctx) {
                return 10 / 10
            }
        }
    }

})

async function main() {
    await broker.start()
}
main()

http://localhost:3000/api/math/div

{
name: "ServiceNotFoundError",
message: "Service 'math.div' is not found.",
code: 404,
type: "SERVICE_NOT_FOUND",
data: {
action: "math.div"
}
}
.......................................................................................











